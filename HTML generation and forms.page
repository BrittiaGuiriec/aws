**Note:** Some compatibility problems have occurred with older versions of [Node.js]() (e.g., 0.6.x). It is recommended that you use the latest version of [Node.js]() (0.8.x).


# My first web server

Creating a simple web server is very easy in [Node.js](). Create a file named `my_server.js` containing the following code

~~~ {.javascript}
var http = require('http');

function handler(req, res) {
  console.log('Received request');
  res.write('Hello world');
  res.end();
}

// We cannot listen on port 80, unless we have root privileges
http.createServer(handler).listen(12345);
console.log('Server started on port 12345');
~~~

Launch the server above by typing

~~~
node my_server.js
~~~

in a terminal. The server is now running and waiting for connections on port 12345 on the localhost. Open your web browser and point it to <http://localhost:12345>. Observe the output in the browser and the terminal.

## Printing debug information on the console

1. The `req` parameter of `handler` has many interesting fields. Two of them are `req.method` and `req.url`. Modify `handler` so that it logs these two fields on the console. 

2. Visit the following addresses and observe the output in the terminal:

    - <http://localhost:12345>;
    - <http://localhost:12345/>;
    - <http://localhost:12345/index.html>;
    - <http://localhost:12345/index.php>;
    - <http://localhost:12345/page?fruit=apple&color=red>.

3. Another very interesting field is `req.headers`: an object containing all the headers sent by the client. Using a `for ... in` loop, print its contents to the console at every request.


## Presenting HTML to the client

1. Modify `handler` so that, instead of just sending 'Hello world' to the client, it sends a complete [HTML]() document.

2. Validate your [HTML]() document using the validator at <http://validator.w3.org>. In the browser, you will have to 'view the page source' (`Ctrl+U` in most browsers), copy the [HTML]() source code, and paste it into the [*Validate by Direct Input*](http://validator.w3.org/#validate_by_input) tab. Correct any errors until the validator is satisfied.

It is very important that you produce valid [HTML]() code. To simplify the validation task, you can install the [Web Developer]() extension in Firefox or Chrome.

3. Modify `handler` so that it sends to the user the list of the headers received in `req.headers`. The list must be formatted as an [HTML table](http://www.w3schools.com/html/html_tables.asp) using the `<table>`, `<tr>` and `<td>` tags. Here is an example of the expected output:

<style>
  #table { border-collapse: collapse }
  #table td { border: solid thin black }
</style>

<table id='table'>
<tr><td>host</td><td>localhost:12345</td></tr>
<tr><td>connection</td><td>keep-alive</td></tr>
<tr><td>cache-control</td><td>max-age=0</td></tr>
<tr><td>accept</td><td>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</td></tr>
<tr><td>user-agent</td><td>Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.69 Safari/537.17</td></td>
<tr><td>accept-encoding</td><td>gzip,deflate,sdch</td></tr>
<tr><td>accept-language</td><td>en-US,en;q=0.8</td></tr>
<tr><td>accept-charset</td><td>ISO-8859-1,utf-8;q=0.7,*;q=0.3</td></tr>
</table>


Do not forget to validate your [HTML]() code!


# Templates with Mustache

In large web applications it is very important to separate the *logic*, written in [JavaScript](), from the *presentation*, written in [HTML](). [*Template languages*](Template language) are small extensions of [HTMl]() specifically targeted toward text transformation. In this tutorial we choose to use [Mustache](http://mustache.github.com/) because of its simplicity, but you are free to use any other template language you like for your personal project.

There are at least two good implementations of Mustache for [Node.js](). They are both optional modules, and have to be installed via a terminal using the `npm` program. Open a terminal, and,  in the same directory where you put all your Node scripts, type

~~~
npm install mustache
~~~

this will download the [`mustache`](https://npmjs.org/package/mustache) module and install it locally into your project directory. For this tutorial we are going to use the `mustache` module, but you may also want to try out [`mu2`](https://npmjs.org/package/mu2) for your project.

Mustache is a logic-less template language, meaning that it contains no construct like if's and loops. Its main element is the double bracket

~~~
{{identifier}}
~~~

also called a *mustache* (because of the similarity between a bracket and a mustache). Mustaches are named labels, indicating to the Mustache compiler that a substitution must take place. A Mustache template is a file containing normal text, along with some mustaches. For example

~~~
This is normal text, and this is a mustache: {{my_value}}.
~~~

Mustache is object oriented. A Mustache compiler expects as input an object whose fields have the same names as the mustaches appearing in the template. It transforms the template by replacing each mustache by the value of the corresponding field.

The method `render` in the module `mustache` is a very simple Mustache compiler.

1. Create a file containing the following code

    ~~~ {.javascript}
    var mu = require('mustache');
    
    var template = "{{greeting}}! Your script is named {{{script}}} and this is a mustache template.";
    console.log(mu.render(template, { greeting : process.argv[2],
                                      script: process.argv[1] }));
    ~~~

    Run the script from a terminal by trying different arguments on the command line.

Apart from ordinary mustaches, Mustache also supports *sections*. A section has the form

~~~
{{#identifier}}
  some more text {{another_mustache}}.
{{/identifier}}
~~~

A section is compiled as follows. If `identifier` is equivalent to `true`, the content of the section is parsed and compiled. If `identifier` is equivalent to `false`, the content of the section is ignored. *Inverted sections* have the syntax

~~~
{{^identifier}}
  some more text {{another_mustache}}.
{{/identifier}}
~~~

and behave the opposite way.

2. Create a file containing the following code and test it

    ~~~ {.javascript}
    var mu = require('mustache');
    
    var template = "{{#a}} here's a pound: # {{/a}}, {{^a}} here's a caret ^ {{/a}}";
    console.log("First try (a=true): " + mu.render(template, { a : true }));
    console.log("Second try (a=false): " + mu.render(template, { a : false }));
    console.log("Third try (a=0): " + mu.render(template, { a : 0 }));
    ~~~

Sections can also be used for looping. If `identifier` is a list, the section is executed once per element of the list, with the context of the section set to the current element of the list.

3. Test the following code

    ~~~ {.javascript}
    var mu = require('mustache');
    
    var template = "{{#fruits}}fruit: {{fruit}}, color: {{color}}\n{{/fruits}}";
    console.log(mu.render(template, { fruits : [
        { fruit: 'apple', color: 'red' },
        { fruit: 'banana', color: 'yellow' },
        { fruit: 'mango', color: 'green' }
    ] }));
    ~~~

For more constructs and features, read the [documentation of the `mustache` module](https://npmjs.org/package/mustache).


Writing large templates in strings is not very comfortable. A better way of using templates is to put them in separate files, and read them at compile time. To read from files we need the `fs` module. Here is the same example as above, but with the template read from a file named `template.mu`.

~~~ {.javascript}
var mu = require('mustache');
var fs = require('fs');

var template = fs.readFileSync('template.mu', 'ascii');

console.log(mu.render(template, { fruits : [
    { fruit: 'apple', color: 'red' },
    { fruit: 'banana', color: 'yellow' },
    { fruit: 'mango', color: 'green' }
] }));
~~~


4. Rewrite the server of the previous section so that the [HTML]() table and code is generated using a Mustache template.

Here is a solution using the [`mu2`](https://npmjs.org/package/mu2) module, rather than `mustache` (the choice of the module only affects the [JavaScript]() code, not the Mustache template).


<div style="max-height:6ex;overflow:hidden"
onclick="if(this.style.maxHeight!='none')this.style.maxHeight='none';else this.style.maxHeight='6ex'">

~~~ {.javascript}
var http = require('http');   // Click to uncover
var mu = require('mu2');

http.createServer(function(req, res) {
    var head = [];
    for (h in req.headers)
        head.push({ name : h,
                    value : req.headers[h] });

    mu.compileAndRender( 'my_server.mu', {headers : head}).pipe(res);
}).listen(12345);
~~~

~~~ {.html}
<!-- Contents of my_server.mu -->
<!DOCTYPE html>
<html>
  <head>
    <title>HTTP Header reflector</title>
  </head>
  <body>
    <table border=1>
    {{#headers}}
      <tr><td>{{name}}</td><td>{{value}}</td></tr>
    {{/headers}}
    </table>
  </body>
</html>
~~~

</div>



# Connect and Forms

The [HTTP]() server created by the `http` module is very primitive. It doesn't even do the most basic tasks related to web programming, such as parsing query strings, parsing cookies, maintaining sessions, etc.

The [`connect`](http://www.senchalabs.org/connect/) module adds to [Node.js]() some very useful tools called *middleware*. `connect` is an optional module and needs to be installed. In a terminal, descend in your project directory and run

~~~
npm install connect
~~~

Middleware are simple tools filtering the request and the response object in a pipeline. For this tutorial, we will only need the [Query](http://www.senchalabs.org/connect/query.html) and [Body Parser](http://www.senchalabs.org/connect/bodyParser.html) middleware, which can be activated by running the server like this.

~~~ {.javascript}
var connect = require('connect');

var handler = function (req, res) {
  // here goes the usual handler code
}

var app = connect()
  .use(connect.query())
  .use(connect.bodyParser())
  .use(handler)
  .listen(12345);
~~~

Once these middleware are activated, GET parameters are automatically loaded into the object `req.query`, POST  parameters are automatically loaded into the object `req.body`.

1. Modify `handler` so that it logs `req.method`, `req.url`, `req.query` and `req.body` to the console for any incoming request.

## Paths

Now we want our server to show different pages depending on what [URL]() was requested in the [HTTP] request. Recall that this information is available in the `req.url` object; however, `req.url` contains the whole *path*, including the *query string* (i.e., including the GET parameters following `?`).

Fortunately, thanks to the Query middleware, the variable `req._parsedUrl.pathname` contains the request [URL]() without the *query string*. The underscore `_` indicates that the object `_parsedUrl` is not part of the public API, and might change in future versions of `connect`, but it will be just fine for this tutorial.

Using a `if` or `switch` construct on `req._parsedUrl.pathname`, we can serve different pages to the client from the same `handler` function. In what follows we will use interchangeably the nouns [URL]() and *path* to talk about the page requested by the client.

2.  Modify `handler` so that when the [URL]() is `/`, it responds with an [HTML]() form like the following

    Name: <input type='text'/>, Town: <input type='text'/> <input type='submit'/>

    The form *method* must be GET, and the form action must be `/hello`.

3. Modify `handler` so that when the [URL]() is `/hello` it responds with a message like the following

    > Hello \<name\> from \<town\>!

    Where \<name\> and \<town\> are values to be taken from the query string. If these values are absent, an error message must be print.

4. Modify the `/` and `/hello` paths to use a POST method instead of GET.


## The reflector

We now get to a very useful tool for debugging: a *reflector*. This is similar in spirit to the previous exercise showing all the [HTTP]() headers to the client.

5. Modify `handler` so that when the [URL]() is `/reflector`, it responds with two [HTML]() tables: one containing all the GET parameters, and one containing all the POST parameters. It is wise to use templates here. Test this path by using various forms and query strings.

6. Modify the path `/` so that it presents a form containing *at least* one **reset**,
    one **button** and two **submit** controls like this:

    ~~~ {.html}
    <input type="button" name="b" value="Something" />
    <input type="reset" name="r" value="Erase" />
    <input type="submit" name="submit" value="Left" />
    <input type="submit" name="submit" value="Right" />
    ~~~

    Test the form by submitting data to the `/reflector` path using both the
    GET and the POST methods.
 
7. Test the `<input type="image">` control.


## Routing (Optional)

When applications become too complex, writing a big `switch` or `if` to map each path to its own script can become a big mess. *Routers* try to simplify things by offering a simple syntax and some parsing facilities.

Install the module [`connect-route`](https://npmjs.org/package/connect-route) with the command

~~~
npm install connect-route
~~~

`connect-route` is yet another, very simple, middleware that runs in the `connect` pipeline. It is used like this:


~~~ {.javascript}
var connect = require('connect');
var route = require('connect-route');

var handler = function (router) {
  router.get('/', function(req, res) {
    // code for path / using get method
  });

  router.get('/hello', function(req, res) {
    // code for path /hello using get method
  });

  router.post('/hello', function(req, res) {
    // code for path /hello using post method
  });
}

var app = connect()
  .use(connect.query())
  .use(connect.bodyParser())
  .use(route(handler))
  .listen(12345);
~~~

`connect-route` also supports a very simple form of wildcard expansion, using the colon `:` operator. In the following code

~~~ {.javascript}
var handler = function (router) {
  router.get('/home/:blabla', function(req, res) {
    console.log(req.params.blabla)
  });
};
~~~

the object `req.params` is filled with a key `blabla` whose value corresponds to the part of the request path following `/home/`, and excluding the query parameters. There are much more complex and powerful routers available for [Node.js](), but we won't discuss them here.

1. Using the `connect-route` router, write a (small) interactive [gamebook](http://en.wikipedia.org/wiki/Gamebook) like the ones in <http://www.ffproject.com/download.htm>.
