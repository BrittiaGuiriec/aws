---
toc: no
categories: Classes HTML Node.js
...


View this as a [slideshow](?export&format=Slidy)


# How does the server speak to the client?

<div class="figure">
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   version="1.1"
   width="900"
   height="300">
  <defs>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Lend"
       style="overflow:visible">
      <path
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         transform="matrix(-0.8,0,0,-0.8,-10,0)"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow2Lstart"
       style="overflow:visible">
      <path
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         transform="matrix(0.8,0,0,0.8,10,0)"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
  </defs>
  <g>
    <image
       xlink:href="/server.png"
       x="300" y="80"
       width="138" height="139" />
    <image
       xlink:href="/php.png"
       x="460" y="90"
       width="95" height="51" />
    <image
       xlink:href="/server.png"
       x="700" y="0"
       style="opacity:0.5"
       width="70" height="70" />
    <image
       xlink:href="/db.png"
       x="700" y="80"
       style="opacity:0.5"
       width="60" height="60" />
    <image
       xlink:href="/document.png"
       x="705" y="160"
       style="opacity:0.3"
       width="44" height="60" />
    <image
       xlink:href="/document.png"
       x="120" y="210"
       style="opacity:0.2"
       width="66" height="90" />
    <path
       d="m 40,120 250,0"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow2Lend)" />
    <path
       d="m 290,150 -250,0"
       id="path4280"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow2Lend)" />
    <path
       d="m 550,90 100,-30"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow2Lend);marker-start:url(#Arrow2Lstart)" />
    <path
       d="m 560,115 90,0"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow2Lend);marker-start:url(#Arrow2Lstart)" />
    <path
       d="m 550,140 100,30"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow2Lend);marker-start:url(#Arrow2Lstart)" />
    <text
       x="0" y="100"
       style="font-family:monospace"
       xml:space="preserve" >GET /app HTTP/1.1</text>
    <text
       x="0" y="190"
       style="font-family:monospace"
       xml:space="preserve" >HTTP/1.1 200 OK</text>
    <text
       x="450" y="190"
       xml:space="preserve" >Scripting</text>
    <text
       x="450" y="220"
       xml:space="preserve" >engine</text>
    <text
       x="620" y="50"
       style="font-size:smaller"
       xml:space="preserve" >Authentication server</text>
    <text
       x="680" y="120"
       style="font-size:smaller"
       xml:space="preserve" >Database</text>
    <text
       x="660" y="210"
       style="font-size:smaller"
       xml:space="preserve" >XML template</text>
    <text
       x="60" y="250"
       xml:space="preserve" >Generated HTML</text>
    <text
       x="100" y="290"
       xml:space="preserve" >document</text>
  </g>
</svg>
</div>

~~~ {.html}
<!DOCTYPE html>
<html>
  <head>
    <title>Hello!</title>
	...
~~~


# HTML markup

[HTML]() is a *markup language*, originally inspirded by SGML, for the
writing of **human readable** (!!!) HyperText documents.

~~~ {.html}
<tag>
  My content <someothertag>some more content</someothertag>
</tag>
~~~

**Tags** delimit textual content:

> - To any opening tag `<tag1>` corresponds a closing tag `</tag1>`.
> - Tags may contain other tags, properly nested.
> - Not any tag can go inside any other tag.
> - Certain tags must have no content. 
    In this case `<tag></tag>` can be shortened to `<tag/>`.


# Attributes

Tags may have **attributes**, going in the opening tag.  

~~~ {.html}
<tag attribute1="value 1"
     attribute2='value 2'
     attribute3=value3>
  Content
</tag>
~~~

> - Attribute values go in simple, double or no quotes.
    Unquoted values (avoid them, though) must contain no spaces.
> - Some attributes are compulsory for certain tags


## Comments

Comments are written between a starting **`<!--`** and closing
**`-->`**

~~~ {.html}
<!-- This is a comment, it will be ignored -->
<tag>This will be parsed</tag>
~~~

Obviously, a comment **is not a tag**. It just looks a bit like one.


# The structure of an HTML document

There is a limited number of tags, the user **may not** invent its own.

Any HTML document **must** look like this

~~~ {.html}
<html>
  <head>
    <!-- The head contains any information 
         on the document that is not content
     -->
    <title>Some title</title>
  </head>
  <body>
    <!-- The body contains the real HyperText -->
  </body>
</html>
~~~


# What goes in the head

The `<head>` section of an [HTML]() document contains everything that
is relevant to the document but that is not part of it. Here's some
important tags.

**`<title>`:** The title of the document. Compulsory.

**`<script>`:** Client-side scripting code ([JavaScript](), VBScript, etc.).

**`<style`>:** Presentation directives ([CSS](), etc.).

**`<meta>`:** Meta-information on the document (language, encoding, etc.).

**`<link>`:** Related documents (feeds, favicons, etc.)

**`<base>`:** Link resolution base.


# What goes in the body

The `<body>` section contains the real content. Here's a little
selection of tags.

**`<section>`, `<nav>`:** Structure of the document.

**`<header>`, `<footer>`, `<aside>`, `<address>`:** Structure of a section.

**`<p>`, `<h1>`, ..., `<h6>`:** A paragraph of text, a first level
  section title, ..., a sixth level section title.

**`<a>`:** An *anchor*, i.e. a link to some other content.

**`<img>`, `<audio>`, `<video>`, `<object>`, `<svg>`:** Embedding media.

**`<form>`, `<input>`, ...:** User interaction.

**`<table>`, `<tr>`, `<td>`, ...:** Tables.

**`<strong>`, `<em>`:** Text presented *differently* (e.g., bold or italic)

**`<div>`, `<span>`:** Tags with absolutely no meaning (useful for
  linking to style and scripts).

Read more on <http://www.w3schools.com>.


# Attributes

Attributes serve many goals. Here's some of the most common.

**`id`:** Assigns an identifier to a tag. Must be unique.

**`class`:** Assigns the tag to a **class** (for logical grouping).

**`src`:** Used to point to the source of external resources.

**`href`:** HyperReference. Used for linking to external resources.

**`style`:** To add styling directives (will talk more about this).

**`title`:** Specify extra information.

**`onclick`, `onload`, `onmouseover`, ...:** Event hooks for scripting.

**`data-*`:** User definable attributes (since [HTML5]()).


# The inline, the block and the ugly

There are rules on which tags can go in which. In the old days, there
used to be two categories:

**Block level:**  `<div>`, `<p>`, `<h1>`, `<form>`, `<td>`, etc.

**Inline (flow) level:** `<span>`, `<a>`, `<strong>`, etc.

> - Blocks can go into blocks,
> - Inlines can go inside inlines or blocks,
> - Blocs cannot go inside inlines.

Plus some other rules (`<td>` inside `<tr>` inside `<table>`, no `<p>`
inside a `<p>`, nothing inside `<img>`, etc.). Things got more
complicated recently with the design of [HTML5]().


# Follow the standards

By striving to ease or enhance web programming, browser developers
have introduced tons of non-standard tags and parsing rules.

This has ultimately led to **bad practices** in web programming and
browser **incompatibilities**.

[W3C]() tries to enforce the standards by providing tools for the
**validation** of web pages.

**Use it:** <http://validator.w3c.org>




# Properly declare your language

You must declare the language and the variant you're writing the
document in. A properly declared [HTML5]() document looks like this
(preferred way in our course)

~~~ {.html}
<!DOCTYPE html>
<html>
    <head>...</head>
    <body>...</body>
</html>
~~~

Or like this (using the [XHTML]() encoding)

~~~ {.html}
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>...</head>
    <body>...</body>
</html>
~~~


# Never said enough: properly nest your tags!

**Good**

~~~ {.html}
<p>
  <strong>This text is bold <em>and this is italic too</em></strong>
</p>
~~~

**BAD!!!!!!!**

~~~ {.html}
<p>
  <strong>This text is bold <em>and this is italic too</strong></em>
</p>
~~~

~~~ {.html}
<p>
  <strong>This text is bold <em>and this is italic too</em></strong>
~~~



# Good practice: declare your character encoding

For example (always prefer Unicode encodings)

~~~ {.html}
<head>
  <meta charset="utf-8" />
  ...
</head>
~~~

or like this (still common on french Windows systems)

~~~ {.html}
<head>
  <meta charset="iso-8859-1" />
  ...
</head>
~~~



# Dynamic generation of content

Every web framework has its own way of dynamically generating
[HTML](). The simplest way in [Node.js]() is by using the `http`
module.

~~~ {.javascript}
var http = require('http');

var handler = function (req, res) {
  res.write('<!DOCTYPE html>');
  res.write('<html>');
  res.write('  <head>');
  res.write('    <title>' + process.argv[0] + '</title>');
  ...
  res.end();
}

http.createServer(handler).listen(80);
~~~


# Separating the logic from the view

For large web pages, this code is tedious to write, hard to read, and
unnecessarily long:

~~~ {.javascript}
var handler = function (req, res) {
  res.write('<!DOCTYPE html>');
  res.write('<html>');
  res.write('  <head>');
  res.write('    <title>' + process.argv[0] + '</title>');
  ...
  res.end();
}
~~~

**Web templates are the solution**

- A web template encodes the **view**, much like an [HTML]() file;
- [Node.js]() handles the **logic**.



# Templates

A web template encodes the **view** (example with [Mustache]())

~~~ {.html}
<!-- Contents of templates/index.mu -->
<!DOCTYPE html>
<html>
  <head>
    <title>{{mytitle}}</title>
	...
~~~

[Node.js]() handles the **logic**

~~~ {.javascript}
var fs = require('fs');        // to read files
var mu = require('mustache');  // Mustache module

var template = fs.readFileSync('templates/index.mu', 'ascii');

var handler = function (req, res) {
    // This substitutes the value of mytitle into the template
	res.end(mu.render(template,
	                  { mytitle : process.argv[0] }));
}
~~~



# How does the client speak to the server?

<div class="figure">
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   version="1.1"
   width="860"
   height="190">
  <defs>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow1Lend"
       style="overflow:visible">
      <path
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         transform="matrix(-0.8,0,0,-0.8,-10,0)"
         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;marker-start:none" />
    </marker>
  </defs>
  <g>
    <image
       xlink:href="/firefox.png"
       x="0" y="30"
       width="138" height="99" />
    <image
       xlink:href="/server.png"
       x="700" y="20"
       width="138" height="139" />
    <path
       d="m 150,60 500,0"
       style="fill:none;stroke:#000000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow1Lend)" />
    <text
       x="25" y="160"
       xml:space="preserve" >CLIENT</text>
    <text
       x="750" y="190"
       xml:space="preserve" >SERVER</text>
    <text
       x="160" y="40"
       style="font-family:monospace"
       xml:space="preserve" >POST /doc?lang=en&q=apples HTTP/1.1</text>
  </g>
</svg>
</div>

~~~
POST /doc?lang=en&q=apples HTTP/1.1
Host: www.example.com
Cookie: sessionid=aa03x;
Content-Length: 23
Content-Type: application/x-www-form-urlencoded
 
user=toto&pass=MyS3cr3t
~~~


# Sending information to the server

Clients need to send information to the server (e.g., authentication
information, search queries, etc.). The three most used methods are:

**GET request:** the data is appended to the URL (**`?`** and
  **`&`** are normally used as separators).

    http://www.google.fr/search?q=web+application&hl=fr

> Better suited for *safe requests* (i.e., requests that do not
> permanently modify data on the server).
    
**POST request:** the data is sent in the body of a POST request.

> Better suited for requests that modify data on the server.

**Cookies:** the data is sent in the Cookie HTTP header.

> Mostly used for [Persistent storage]().
  
Any combination of the three is possible.



# How to get the user input in a friendlier manner?

Obviously, the average user doesn't want to (and doesn't know how to)
manually type its input in the body of an [HTTP]() request.

Web technologies offer an interesting palette of solutions to this
problem

- [HTML forms]()

    <div style="text-align:center">
    <input type="text" name="text-input-example" placeholder="type something" />
    <input type="button" name="submit-example" value="Go!" />
    </div>
    
    can send data using **both** GET and POST methods.

- [Cookies](Cookie) are normally set by the browser (following a request by
    the server) **without user interaction**. They are used for
    [Persistent storage]().
  
- [JavaScript]() is able to fill and submit [HTML forms]() and to set
  [Cookies](Cookie).
  
- [XMLHttpRequest]() (a [JavaScript]() object) can perform directly
    GET and POST requests **with or without user interaction**. This
    is the basis of [AJAX]().


# HTML forms

<div style="text-align:center;display:inline-block;max-width:15%">
<img src="/server.png" width="90%" height="90%">
<p style="font-size:smaller">www.captcha.net</p>
</div>
<svg
   id="post-img"
   style="opacity:0.3"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   version="1.1"
   width="25%"
   height="60%">
  <defs>
    <marker
       refX="0"
       refY="0"
       orient="auto"
       id="Arrow1Lend"
       style="overflow:visible">
      <path
         d="M 0,0 5,-5 -12.5,0 5,5 0,0 z"
         transform="matrix(-0.8,0,0,-0.8,-10,0)"
         style="fill-rule:evenodd;stroke:#000;stroke-width:1pt;marker-start:none" />
    </marker>
  </defs>
  <g style="font-size:smaller;font-family:monospace">
    <text x="20" y="10%" xml:space="preserve">POST /user HTTP/1.1</text>
    <text x="20" y="17%" xml:space="preserve">Host: www.captcha.net</text>
    <text x="20" y="24%" xml:space="preserve">...</text>
    <text x="20" y="38%" xml:space="preserve">first=Alan&</text>
    <text x="20" y="45%" xml:space="preserve">last=Turing&</text>
    <text x="20" y="52%" xml:space="preserve">sex=M&</text>
    <text x="20" y="59%" xml:space="preserve">email=alan@gchq.gov.uk</text>
    <line x1="100%" y1="80%" x2="1%" y2="80%"
       style="fill:none;stroke:#000;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;marker-end:url(#Arrow1Lend)" />
  </g>
</svg>
<div style="max-width:60%;display:inline-block;">
<label for="name">First name:</label>
<input type="text" value="Alan" name="first" id="first" />
<br \>
<label for="name">Last name:</label>
<input type="text" value="Turing" name="last" id="last" />
<br \>
Gender: <label for="male">Male</label>
<input type="radio" name="sex" id="male" value="M" checked />
<label for="female">Female</label>
<input type="radio" name="sex" id="female" value="F" />
<br \>
<label for="email">e-mail:</label>
<input type="email" value="alan@gchq.gov.uk" name="email" id="email" />
<br \>
<input type="button" value="Subscribe" onclick="document.getElementById('post-img').style.opacity=1;" />

~~~ {.html}
<form method="POST"
      action="http://www.captcha.net/user">
  First name:
  <input type="text" name="first" />
  <br \>
  Last name:
  <input type="text" name="last" />
  <br \>
  Gender: Male
  <input type="radio" name="sex" value="M" />
  Female
  <input type="radio" name="sex" value="F" />
  <br \>
  e-mail:
  <input type="email" name="email" />
  <br \>
  <input type="submit" value="Subscribe" />
</form>
~~~

</div>



# Form controls

The **`<input>`** tag represents almost all form controls. The choice
is done by the **`type`** attribute.

**Text fields:** <input type="text" placeholder="type something" />

~~~ {.html}
<input type="text" />
~~~

**Radio buttons:** <input type="radio" name="choice" value="1" /> A <input type="radio" name="choice" value="2" /> B

~~~ {.html}
<input type="radio" name="choice" value="choice-1" /> A
<input type="radio" name="choice" value="choice-2" /> B
~~~

**Checkbox:** <input type="checkbox" name="check" value="1" /> C <input type="checkbox" name="check" value="2" /> D

~~~ {.html}
<input type="checkbox" name="check" value="check-1" />
<input type="checkbox" name="check" value="check-2" />
~~~

**Password:** <input type="password" value="strongpass" />

~~~ {.html}
<input type="password" />
~~~


---------------


**File:** <input type="file" />

~~~ {.html}
<input type="file" />
~~~

**Submit:** (more on this later) <input type="submit" value="Send data" />

~~~ {.html}
<input type="submit" value="Send data" />
~~~


**Button:** (mostly used with [Javascript]()) <input type="button" value="Click me!" />

~~~ {.html}
<input type="button" value="Click me!" />
~~~


**Image:** (submits the click coordinates) <input type="image" src="/like.svg" width="40" alt="Like!" />

~~~ {.html}
<input type="image" src="like.svg" alt="Like!" />
~~~

**Email:** (since [HTML5](HTML), checks for @) <input type="email" />

~~~ {.html}
<input type="email" />
~~~


More new types defined in [HTML5](HTML) (mostly not implemented yet):
**date**, **time**, **number**, **range**, **color**, **tel**,
**url**, ...



# Other form controls

**Text area:** <textarea> Some very very long text </textarea>

~~~ {.html}
<textarea>
Some very very long text
</textarea>
~~~


**Selection list:**
<select>
  <option value="M">MySQL injection</option>
  <option value="X">XSS</option>
  <option value="C">CSRF</option>
</select>

~~~ {.html}
<select>
  <option value="M">MySQL injection</option>
  <option value="X">XSS</option>
  <option value="C">CSRF</option>
</select>
~~~


New (badly supported) form controls in [HTML5](HTML):
**`<datalist>`**, **`<keygen>`** and **`<output>`**.



# What is sent where

~~~ {.html}
<form method="POST"
      action="/script.php" >
  <input type="text" name="key1" />
  <input type="text" name="key2" />
  <!-- More input controls... -->
  <input type="submit" />
</form>
~~~

When the user clicks a **submit** control:

- The browser sends a [HTTP]() request to **`/script.php`**, the HTTP
    method is either **GET** or **POST**, depending on the
    **`method`** attribute:
    
    - if the method is **GET**, the request is sent to
    
            /script.php?key1=value1&key2=value2
        
        where the values come from the user input.
        
    - if the method is **POST**, the data is transmitted in the body
      of the request using the same format.

- The browser **waits for the server response** and presents it to the
  user.



# Form validation

[HTML5]() introduces some handy mechanism to warn the user about
errors in his input.

<style>
.validation:invalid {background-color:#F66}
</style>


**`required`** attribute: warns if not filled <input class="validation" type="text" required>

~~~ {.html}
<input type="text" required>
~~~

**`pattern`** attribute: regexp match against a pattern <input class="validation" type="text" pattern="[0-9]{6}" />

~~~ {.html}
<input type="text" pattern="[0-9]{6}" />
~~~

**`placeholder`** attribute: gives a suggestion to the user <input class="validation" type="text" placeholder="type something" />

~~~ {.html}
<input type="text" placeholder="type something" />
~~~

**`novalidate`** attribute: deactivates all the previous validations.


Plus other standard controls (e.g., urls, emails, etc.) and attributes
related to ranges, files, numbers, etc.

More complex validation can be done through [Javascript]().



# Never trust the form validation!

Form validation is done by the browser (on the client side). There are
many reasons why it could fail:

> - The browser is old.
> - The client has deactivated validation on purpose (for example, using the [Web Developer]() extension).
> - The client is a robot (spammer, worm, etc...).

For these reasons, **always check your inputs on the server side**.

Most of the **security holes** in web applications come from this simple
mistake.


# Parsing the data on the server side

The server must make the GET and POST parameters available to the
server side scripts. 

In [Node.js]() this is done by optional modules called *middleware*
(e.g., the `connect` module)

~~~ {.javascript}
var conn = require('connect');   // middleware module

var handler = function (req, res) {
  ...
}

var app = conn().use(handler).listen(80);
~~~


# The `connect` module

Parse **GET** parameters: using the `connect.query()` middleware.

~~~ {.javascript}
// contents of echo_get.js
var conn = require('connect');

var handler = function (req, res) {
  console.log(req.query);
  res.end();
}

var app = conn().use(conn.query()).use(handler).listen(80);
~~~

**Example:** output on request for `?fruit=apple&color=red`.

~~~
$ node echo_get.js
{ fruit: 'apple', color: 'red' }
~~~


# The `connect` module

Parse **POST** parameters: using the `connect.bodyParser()` middleware.

~~~ {.javascript}
// contents of echo_post.js
var conn = require('connect');

var handler = function (req, res) {
  console.log(req.body);
  res.end();
}

var app = conn().use(conn.bodyParser()).use(handler).listen(80);
~~~

**Example:** output on request body containing `fruit=apple&color=red`.

~~~
$ node echo_post.js
{ fruit: 'apple', color: 'red' }
~~~

